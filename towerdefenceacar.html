<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense RPG</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #222;
            color: white;
            overflow: hidden;
        }
        #gameContainer {
            display: flex;
            height: 100vh;
        }
        #gameCanvas {
            background-color: #111;
            flex: 1;
        }
        #sidebar {
            width: 200px;
            background-color: #333;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }
        .tower-btn {
            margin: 5px 0;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        .tower-btn:hover {
            transform: translateY(-2px);
        }
        #fire-tower {
            background-color: #ff5733;
        }
        #ice-tower {
            background-color: #33b5ff;
        }
        #poison-tower {
            background-color: #5dff33;
        }
        #barracks {
            background-color: #c733ff;
        }
        #resources {
            margin-top: 20px;
            padding: 10px;
            background-color: #444;
            border-radius: 5px;
        }
        #wave-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #444;
            border-radius: 5px;
        }
        #upgrade-panel {
            margin-top: 20px;
            padding: 10px;
            background-color: #444;
            border-radius: 5px;
            display: none;
        }
        #upgrade-btn {
            margin-top: 10px;
            padding: 5px;
            background-color: gold;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #restart-btn {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #ff5733;
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        .status-effect {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            animation: float-up 1s forwards;
        }
        @keyframes float-up {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="sidebar">
            <h2>Tower Defense RPG</h2>
            <button id="fire-tower" class="tower-btn">Fire Tower (50g)</button>
            <button id="ice-tower" class="tower-btn">Ice Tower (60g)</button>
            <button id="poison-tower" class="tower-btn">Poison Tower (70g)</button>
            <button id="barracks" class="tower-btn">Barracks (100g)</button>
            
            <div id="resources">
                <p>Gold: <span id="gold">200</span></p>
                <p>Lives: <span id="lives">20</span></p>
            </div>
            
            <div id="wave-info">
                <p>Wave: <span id="wave">1</span></p>
                <p>Enemies: <span id="enemies">0</span></p>
                <button id="start-wave">Start Wave</button>
            </div>
            
            <div id="upgrade-panel">
                <h3>Upgrade Tower</h3>
                <p>Type: <span id="selected-type"></span></p>
                <p>Level: <span id="selected-level"></span></p>
                <p>Cost: <span id="upgrade-cost"></span> gold</p>
                <button id="upgrade-btn">Upgrade</button>
                <button id="sell-btn">Sell</button>
            </div>
        </div>
    </div>
    
    <div id="game-over">
        <h2>Game Over!</h2>
        <p>You survived <span id="final-wave">0</span> waves</p>
        <button id="restart-btn">Restart Game</button>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameWidth, gameHeight;
        let cellSize = 40;
        let grid = [];
        let path = [];
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let soldiers = [];
        let effects = [];
        let waveNumber = 1;
        let gold = 200;
        let lives = 20;
        let placingTower = null;
        let selectedTower = null;
        let waveInProgress = false;
        let gameOver = false;
        
        // Tower types and their properties
        const towerTypes = {
            fire: {
                name: 'Fire Tower',
                color: '#ff5733',
                baseCost: 50,
                baseRange: 3,
                baseDamage: 20,
                attackSpeed: 1000,
                projectileColor: '#ff5733',
                levels: [
                    { range: 3, damage: 20, upgradeCost: 40 },
                    { range: 4, damage: 35, upgradeCost: 60 },
                    { range: 5, damage: 55, upgradeCost: null }
                ],
                effect: {
                    type: 'burn',
                    chance: 0.3,
                    damage: 5,
                    duration: 3,
                    color: '#ff5733'
                }
            },
            ice: {
                name: 'Ice Tower',
                color: '#33b5ff',
                baseCost: 60,
                baseRange: 2,
                baseDamage: 15,
                attackSpeed: 800,
                projectileColor: '#33b5ff',
                levels: [
                    { range: 2, damage: 15, upgradeCost: 50 },
                    { range: 3, damage: 25, upgradeCost: 70 },
                    { range: 4, damage: 40, upgradeCost: null }
                ],
                effect: {
                    type: 'slow',
                    chance: 0.5,
                    amount: 0.5,
                    duration: 3,
                    color: '#33b5ff'
                }
            },
            poison: {
                name: 'Poison Tower',
                color: '#5dff33',
                baseCost: 70,
                baseRange: 2,
                baseDamage: 10,
                attackSpeed: 1200,
                projectileColor: '#5dff33',
                levels: [
                    { range: 2, damage: 10, upgradeCost: 60 },
                    { range: 3, damage: 18, upgradeCost: 80 },
                    { range: 3, damage: 30, upgradeCost: null }
                ],
                effect: {
                    type: 'poison',
                    chance: 0.7,
                    damage: 3,
                    duration: 5,
                    color: '#5dff33'
                }
            },
            barracks: {
                name: 'Barracks',
                color: '#c733ff',
                baseCost: 100,
                baseRange: 0,
                baseDamage: 0,
                attackSpeed: 0,
                levels: [
                    { soldiers: 2, health: 50, damage: 10, upgradeCost: 80 },
                    { soldiers: 3, health: 80, damage: 15, upgradeCost: 120 },
                    { soldiers: 4, health: 120, damage: 25, upgradeCost: null }
                ]
            }
        };
        
        // Enemy types
        const enemyTypes = {
            normal: {
                name: 'Normal',
                color: '#888',
                speed: 1,
                health: 100,
                reward: 10,
                resistances: {},
                weaknesses: {}
            },
            armored: {
                name: 'Armored',
                color: '#555',
                speed: 0.7,
                health: 200,
                reward: 15,
                resistances: { fire: 0.5 },
                weaknesses: { poison: 1.5 }
            },
            fast: {
                name: 'Fast',
                color: '#ff9933',
                speed: 1.5,
                health: 60,
                reward: 8,
                resistances: { poison: 0.5 },
                weaknesses: { ice: 1.5 }
            },
            magic: {
                name: 'Magic',
                color: '#9333ff',
                speed: 0.8,
                health: 150,
                reward: 20,
                resistances: { ice: 0.5 },
                weaknesses: { fire: 1.5 }
            },
            boss: {
                name: 'Boss',
                color: '#ff3333',
                speed: 0.5,
                health: 500,
                reward: 50,
                resistances: { fire: 0.7, ice: 0.7, poison: 0.7 },
                weaknesses: {}
            }
        };
        
        // Initialize the game when the window loads
        window.onload = function() {
            resizeCanvas();
            initializeGame();
            setupEventListeners();
            gameLoop();
        };
        
        // Resize the canvas to fit the window
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth - 220;
            canvas.height = window.innerHeight;
            gameWidth = Math.floor(canvas.width / cellSize);
            gameHeight = Math.floor(canvas.height / cellSize);
        }
        
        // Initialize the game grid and path
        function initializeGame() {
            // Create grid
            grid = [];
            for (let y = 0; y < gameHeight; y++) {
                grid[y] = [];
                for (let x = 0; x < gameWidth; x++) {
                    grid[y][x] = { type: 'empty', tower: null };
                }
            }
            
            // Create path
            createPath();
            
            // Mark path tiles on grid
            for (let i = 0; i < path.length; i++) {
                const { x, y } = path[i];
                if (x >= 0 && x < gameWidth && y >= 0 && y < gameHeight) {
                    grid[y][x].type = 'path';
                }
            }
            
            // Reset game state
            towers = [];
            enemies = [];
            projectiles = [];
            soldiers = [];
            effects = [];
            waveNumber = 1;
            gold = 200;
            lives = 20;
            waveInProgress = false;
            gameOver = false;
            
            updateUI();
        }
        
        // Create a path from left to right with some turns
        function createPath() {
            path = [];
            let x = 0;
            let y = Math.floor(gameHeight / 2);
            
            // Start point
            path.push({ x, y });
            
            // Create horizontal and vertical segments
            while (x < gameWidth - 1) {
                // Decide direction - horizontal or vertical
                if (Math.random() > 0.3 || x < 3) { // Mostly horizontal movement
                    x++;
                } else {
                    // Vertical movement
                    const direction = Math.random() > 0.5 ? 1 : -1;
                    const length = Math.floor(Math.random() * 3) + 2;
                    
                    for (let i = 0; i < length; i++) {
                        const newY = y + direction;
                        if (newY >= 1 && newY < gameHeight - 1) {
                            y = newY;
                            path.push({ x, y });
                        }
                    }
                    
                    // Continue horizontal after vertical segment
                    x++;
                }
                
                path.push({ x, y });
            }
        }
        
        // Set up event listeners for user interaction
        function setupEventListeners() {
            // Tower placement buttons
            document.getElementById('fire-tower').addEventListener('click', () => setPlacingTower('fire'));
            document.getElementById('ice-tower').addEventListener('click', () => setPlacingTower('ice'));
            document.getElementById('poison-tower').addEventListener('click', () => setPlacingTower('poison'));
            document.getElementById('barracks').addEventListener('click', () => setPlacingTower('barracks'));
            
            // Start wave button
            document.getElementById('start-wave').addEventListener('click', startWave);
            
            // Canvas click event for tower placement and selection
            canvas.addEventListener('click', handleCanvasClick);
            
            // Mouse move event for tower preview
            canvas.addEventListener('mousemove', handleMouseMove);
            
            // Upgrade and sell buttons
            document.getElementById('upgrade-btn').addEventListener('click', upgradeTower);
            document.getElementById('sell-btn').addEventListener('click', sellTower);
            
            // Restart button
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            
            // Resize event
            window.addEventListener('resize', () => {
                resizeCanvas();
                drawGame();
            });
        }
        
        // Handle the tower placement mode
        function setPlacingTower(type) {
            const towerInfo = towerTypes[type];
            if (gold >= towerInfo.baseCost) {
                placingTower = type;
                selectedTower = null;
                document.getElementById('upgrade-panel').style.display = 'none';
            } else {
                createFloatingText(canvas.width / 2, canvas.height / 2, "Not enough gold!", "#ff0000");
            }
        }
        
        // Handle canvas click for tower placement and selection
        function handleCanvasClick(event) {
            if (gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / cellSize);
            const y = Math.floor((event.clientY - rect.top) / cellSize);
            
            // Check if coordinates are within bounds
            if (x < 0 || x >= gameWidth || y < 0 || y >= gameHeight) return;
            
            // Place tower if in placing mode
            if (placingTower) {
                placeTower(x, y);
            } else {
                // Select tower if not in placing mode
                selectTower(x, y);
            }
        }
        
        // Handle mouse move for tower preview
        function handleMouseMove(event) {
            if (!placingTower) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Redraw the game with tower preview
            drawGame();
            
            // Draw tower preview
            const x = Math.floor(mouseX / cellSize);
            const y = Math.floor(mouseY / cellSize);
            
            if (x >= 0 && x < gameWidth && y >= 0 && y < gameHeight) {
                const cell = grid[y][x];
                
                if (cell.type === 'empty') {
                    const towerInfo = towerTypes[placingTower];
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = towerInfo.color;
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    
                    // Draw range preview
                    const range = towerInfo.levels[0].range;
                    ctx.beginPath();
                    ctx.arc((x + 0.5) * cellSize, (y + 0.5) * cellSize, range * cellSize, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else {
                    // Cannot place here
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    ctx.globalAlpha = 1;
                }
            }
        }
        
        // Place a tower at the specified position
        function placeTower(x, y) {
            const cell = grid[y][x];
            
            if (cell.type === 'empty') {
                const towerInfo = towerTypes[placingTower];
                
                if (gold >= towerInfo.baseCost) {
                    // Create the tower
                    const tower = {
                        type: placingTower,
                        x: x,
                        y: y,
                        level: 1,
                        lastAttack: 0,
                        target: null,
                        soldiers: []
                    };
                    
                    // Add tower to the game
                    towers.push(tower);
                    grid[y][x].type = 'tower';
                    grid[y][x].tower = tower;
                    
                    // Deduct gold
                    gold -= towerInfo.baseCost;
                    updateUI();
                    
                    // Create soldiers if it's a barracks
                    if (placingTower === 'barracks') {
                        createSoldiers(tower);
                    }
                    
                    // Reset placing tower
                    placingTower = null;
                } else {
                    createFloatingText(canvas.width / 2, canvas.height / 2, "Not enough gold!", "#ff0000");
                }
            }
        }
        
        // Select a tower for upgrade or inspection
        function selectTower(x, y) {
            const cell = grid[y][x];
            
            if (cell.type === 'tower') {
                selectedTower = cell.tower;
                updateUpgradePanel();
            } else {
                selectedTower = null;
                document.getElementById('upgrade-panel').style.display = 'none';
            }
        }
        
        // Update the upgrade panel UI
        function updateUpgradePanel() {
            const panel = document.getElementById('upgrade-panel');
            
            if (selectedTower) {
                const towerInfo = towerTypes[selectedTower.type];
                document.getElementById('selected-type').textContent = towerInfo.name;
                document.getElementById('selected-level').textContent = selectedTower.level;
                
                // Check if tower can be upgraded
                if (selectedTower.level < 3) {
                    const upgradeCost = towerInfo.levels[selectedTower.level - 1].upgradeCost;
                    document.getElementById('upgrade-cost').textContent = upgradeCost;
                    document.getElementById('upgrade-btn').disabled = gold < upgradeCost;
                    document.getElementById('upgrade-btn').style.display = 'block';
                } else {
                    document.getElementById('upgrade-btn').style.display = 'none';
                }
                
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }
        
        // Upgrade the selected tower
        function upgradeTower() {
            if (!selectedTower || selectedTower.level >= 3) return;
            
            const towerInfo = towerTypes[selectedTower.type];
            const upgradeCost = towerInfo.levels[selectedTower.level - 1].upgradeCost;
            
            if (gold >= upgradeCost) {
                gold -= upgradeCost;
                selectedTower.level++;
                
                // If it's a barracks, update soldiers
                if (selectedTower.type === 'barracks') {
                    // Remove old soldiers
                    soldiers = soldiers.filter(s => s.tower !== selectedTower);
                    // Create new soldiers
                    createSoldiers(selectedTower);
                }
                
                updateUI();
                updateUpgradePanel();
            }
        }
        
        // Sell the selected tower
        function sellTower() {
            if (!selectedTower) return;
            
            const towerInfo = towerTypes[selectedTower.type];
            let refund = towerInfo.baseCost * 0.7; // 70% refund
            
            // Add refund for upgrades
            for (let i = 1; i < selectedTower.level; i++) {
                refund += towerInfo.levels[i - 1].upgradeCost * 0.7;
            }
            
            gold += Math.floor(refund);
            
            // Remove tower from grid
            grid[selectedTower.y][selectedTower.x].type = 'empty';
            grid[selectedTower.y][selectedTower.x].tower = null;
            
            // Remove tower from towers array
            towers = towers.filter(t => t !== selectedTower);
            
            // If it's a barracks, remove soldiers
            if (selectedTower.type === 'barracks') {
                soldiers = soldiers.filter(s => s.tower !== selectedTower);
            }
            
            selectedTower = null;
            document.getElementById('upgrade-panel').style.display = 'none';
            updateUI();
        }
        
        // Create soldiers for a barracks
        function createSoldiers(tower) {
            const barracksInfo = towerTypes.barracks.levels[tower.level - 1];
            const pathIndex = findClosestPathIndex(tower.x, tower.y);
            
            for (let i = 0; i < barracksInfo.soldiers; i++) {
                const soldier = {
                    tower: tower,
                    x: tower.x * cellSize + cellSize / 2,
                    y: tower.y * cellSize + cellSize / 2,
                    targetPathIndex: pathIndex,
                    health: barracksInfo.health,
                    maxHealth: barracksInfo.health,
                    damage: barracksInfo.damage,
                    target: null,
                    lastAttack: 0,
                    attackSpeed: 1000,
                    speed: 0.8,
                    color: '#c733ff'
                };
                
                soldiers.push(soldier);
            }
        }
        
        // Find the closest path index to a position
        function findClosestPathIndex(x, y) {
            let closestDistance = Infinity;
            let closestIndex = 0;
            
            for (let i = 0; i < path.length; i++) {
                const distance = Math.sqrt(
                    Math.pow(path[i].x - x, 2) + 
                    Math.pow(path[i].y - y, 2)
                );
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestIndex = i;
                }
            }
            
            return closestIndex;
        }
        
        // Start a new wave of enemies
        function startWave() {
            if (waveInProgress) return;
            
            waveInProgress = true;
            document.getElementById('start-wave').disabled = true;
            
            // Create enemies for this wave
            createEnemiesForWave();
            
            updateUI();
        }
        
        // Create enemies for the current wave
        function createEnemiesForWave() {
            const enemyCount = 5 + Math.floor(waveNumber * 1.5);
            let spawnDelay = 0;
            
            for (let i = 0; i < enemyCount; i++) {
                setTimeout(() => {
                    // Determine enemy type based on wave number
                    let type = 'normal';
                    const rand = Math.random();
                    
                    if (waveNumber >= 3 && rand < 0.3) {
                        type = 'fast';
                    } else if (waveNumber >= 5 && rand < 0.5) {
                        type = 'armored';
                    } else if (waveNumber >= 7 && rand < 0.7) {
                        type = 'magic';
                    }
                    
                    // Boss every 5 waves
                    if (waveNumber % 5 === 0 && i === enemyCount - 1) {
                        type = 'boss';
                    }
                    
                    const enemyInfo = enemyTypes[type];
                    
                    // Scale health with wave number
                    const healthMultiplier = 1 + (waveNumber - 1) * 0.1;
                    
                    // Create the enemy
                    const enemy = {
                        type: type,
                        x: path[0].x * cellSize + cellSize / 2,
                        y: path[0].y * cellSize + cellSize / 2,
                        pathIndex: 0,
                        health: enemyInfo.health * healthMultiplier,
                        maxHealth: enemyInfo.health * healthMultiplier,
                        speed: enemyInfo.speed,
                        baseSpeed: enemyInfo.speed,
                        color: enemyInfo.color,
                        reward: enemyInfo.reward,
                        resistances: enemyInfo.resistances,
                        weaknesses: enemyInfo.weaknesses,
                        effects: []
                    };
                    
                    enemies.push(enemy);
                    updateUI();
                    
                }, spawnDelay);
                
                spawnDelay += 1000;
            }
        }
        
        // Update the game state
        function updateGame() {
            if (gameOver) return;
            
            const now = Date.now();
            
            // Update towers
            updateTowers(now);
            
            // Update projectiles
            updateProjectiles();
            
            // Update enemies
            updateEnemies();
            
            // Update soldiers
            updateSoldiers(now);
            
            // Update effects
            updateEffects();
            
            // Check if wave is complete
            checkWaveCompletion();
            
            // Check game over
            if (lives <= 0) {
                gameOver = true;
                document.getElementById('game-over').style.display = 'block';
                document.getElementById('final-wave').textContent = waveNumber;
            }
        }
        
        // Update tower actions
        function updateTowers(now) {
            towers.forEach(tower => {
                if (tower.type === 'barracks') return; // Barracks don't attack directly
                
                const towerInfo = towerTypes[tower.type];
                const levelInfo = towerInfo.levels[tower.level - 1];
                const range = levelInfo.range;
                
                // Check if tower can attack
                if (now - tower.lastAttack >= towerInfo.attackSpeed) {
                    // Find target
                    let target = null;
                    let maxPathIndex = -1;
                    
                    for (const enemy of enemies) {
                        const dx = (tower.x + 0.5) * cellSize - enemy.x;
                        const dy = (tower.y + 0.5) * cellSize - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) / cellSize;
                        
                        if (distance <= range && enemy.pathIndex > maxPathIndex) {
                            target = enemy;
                            maxPathIndex = enemy.pathIndex;
                        }
                    }
                    
                    // Attack if target found
                    if (target) {
                        tower.lastAttack = now;
                        
                        // Create projectile
                        const projectile = {
                            x: (tower.x + 0.5) * cellSize,
                            y: (tower.y + 0.5) * cellSize,
                            targetEnemy: target,
                            speed: 5,
                            damage: levelInfo.damage,
                            type: tower.type,
                            color: towerInfo.projectileColor,
                            effect: towerInfo.effect
                        };
                        
                        projectiles.push(projectile);
                    }
                }
            });
        }
        
        // Update projectile movement
        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                const target = projectile.targetEnemy;
                
                // Check if target still exists
                if (!enemies.includes(target)) {
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Move projectile towards target
                const dx = target.x - projectile.x;
                const dy = target.y - projectile.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= projectile.speed) {
                    // Hit target
                    applyDamage(target, projectile);
                    projectiles.splice(i, 1);
                } else {
                    // Move towards target
                    projectile.x += (dx / distance) * projectile.speed;
                    projectile.y += (dy / distance) * projectile.speed;
                }
            }
        }
        
        // Apply damage and effects to enemy
        function applyDamage(enemy, projectile) {
            let damage = projectile.damage;
            
            // Check resistances and weaknesses
            if (enemy.resistances[projectile.type]) {
                damage *= enemy.resistances[projectile.type];
                createFloatingText(enemy.x, enemy.y, "Resist!", "#ffff00");
            } else if (enemy.weaknesses[projectile.type]) {
                damage *= enemy.weaknesses[projectile.type];
                createFloatingText(enemy.x, enemy.y, "Weak!", "#ff0000");
            }
            
            // Apply damage
            enemy.health -= damage;
            createFloatingText(enemy.x, enemy.y - 10, `-${Math.round(damage)}`, "#ffffff");
            
            // Apply effect
            if (projectile.effect && Math.random() < projectile.effect.chance) {
                applyStatusEffect(enemy, projectile.effect);
            }
            
            // Check if enemy is dead
            if (enemy.health <= 0) {
                killEnemy(enemy);
            }
        }
        
        // Apply status effect to enemy
        function applyStatusEffect(enemy, effectInfo) {
// Apply status effect to enemy
            // Check if effect already exists
            const existingEffect = enemy.effects.find(e => e.type === effectInfo.type);
            
            if (existingEffect) {
                // Reset duration
                existingEffect.duration = effectInfo.duration;
            } else {
                // Add new effect
                const effect = {
                    type: effectInfo.type,
                    duration: effectInfo.duration,
                    ...effectInfo
                };
                
                enemy.effects.push(effect);
                createFloatingText(enemy.x, enemy.y + 10, effect.type, effect.color);
                
                // Apply immediate effect
                if (effect.type === 'slow') {
                    enemy.speed = enemy.baseSpeed * (1 - effect.amount);
                }
            }
        }
        
        // Update enemy effects
        function updateEffects() {
            for (const enemy of enemies) {
                for (let i = enemy.effects.length - 1; i >= 0; i--) {
                    const effect = enemy.effects[i];
                    
                    // Decrease duration
                    effect.duration -= 0.016; // Approx 1 frame at 60fps
                    
                    // Apply continuous effects
                    if (effect.type === 'burn' || effect.type === 'poison') {
                        enemy.health -= effect.damage * 0.016;
                        
                        // Periodically show damage
                        if (Math.random() < 0.02) {
                            createFloatingText(
                                enemy.x + (Math.random() * 20 - 10),
                                enemy.y + (Math.random() * 20 - 10),
                                effect.type,
                                effect.color
                            );
                        }
                        
                        // Check if enemy died from effect
                        if (enemy.health <= 0) {
                            killEnemy(enemy);
                            break;
                        }
                    }
                    
                    // Remove expired effects
                    if (effect.duration <= 0) {
                        // Reset any changes
                        if (effect.type === 'slow') {
                            enemy.speed = enemy.baseSpeed;
                        }
                        
                        enemy.effects.splice(i, 1);
                    }
                }
            }
        }
        
        // Kill an enemy and gain rewards
        function killEnemy(enemy) {
            gold += enemy.reward;
            const index = enemies.indexOf(enemy);
            if (index !== -1) {
                enemies.splice(index, 1);
            }
            updateUI();
        }
        
        // Update enemy movement
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Move enemy along path
                if (enemy.pathIndex < path.length - 1) {
                    const targetX = path[enemy.pathIndex + 1].x * cellSize + cellSize / 2;
                    const targetY = path[enemy.pathIndex + 1].y * cellSize + cellSize / 2;
                    
                    const dx = targetX - enemy.x;
                    const dy = targetY - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= enemy.speed) {
                        // Reached current waypoint
                        enemy.x = targetX;
                        enemy.y = targetY;
                        enemy.pathIndex++;
                    } else {
                        // Move towards waypoint
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                    }
                } else {
                    // Enemy reached the end
                    lives--;
                    enemies.splice(i, 1);
                    updateUI();
                }
            }
        }
        
        // Update soldier movement and attacks
        function updateSoldiers(now) {
            for (const soldier of soldiers) {
                let actingOnTarget = false;
                
                // Check if soldier has a target
                if (soldier.target && enemies.includes(soldier.target)) {
                    const dx = soldier.target.x - soldier.x;
                    const dy = soldier.target.y - soldier.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= cellSize / 2) {
                        // Attack target
                        actingOnTarget = true;
                        
                        if (now - soldier.lastAttack >= soldier.attackSpeed) {
                            soldier.lastAttack = now;
                            soldier.target.health -= soldier.damage;
                            
                            createFloatingText(
                                soldier.target.x,
                                soldier.target.y,
                                `-${soldier.damage}`,
                                "#ffffff"
                            );
                            
                            // Check if target is dead
                            if (soldier.target.health <= 0) {
                                killEnemy(soldier.target);
                                soldier.target = null;
                            }
                        }
                    } else {
                        // Move towards target
                        actingOnTarget = true;
                        soldier.x += (dx / distance) * soldier.speed;
                        soldier.y += (dy / distance) * soldier.speed;
                    }
                } else {
                    // Find new target
                    soldier.target = null;
                    
                    // Find closest enemy
                    let closestEnemy = null;
                    let closestDistance = cellSize * 5; // Detection range
                    
                    for (const enemy of enemies) {
                        const pathDiff = Math.abs(enemy.pathIndex - soldier.targetPathIndex);
                        if (pathDiff <= 5) { // Only target enemies near soldier's patrol area
                            const dx = enemy.x - soldier.x;
                            const dy = enemy.y - soldier.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestEnemy = enemy;
                            }
                        }
                    }
                    
                    if (closestEnemy) {
                        soldier.target = closestEnemy;
                    }
                }
                
                // If no target, patrol near path
                if (!actingOnTarget) {
                    const pathIndex = soldier.targetPathIndex % path.length;
                    const targetX = path[pathIndex].x * cellSize + cellSize / 2;
                    const targetY = path[pathIndex].y * cellSize + cellSize / 2;
                    
                    const dx = targetX - soldier.x;
                    const dy = targetY - soldier.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= soldier.speed) {
                        // Reached patrol point, pick a new one
                        soldier.targetPathIndex = (soldier.targetPathIndex + 1) % path.length;
                    } else {
                        // Move towards patrol point
                        soldier.x += (dx / distance) * soldier.speed;
                        soldier.y += (dy / distance) * soldier.speed;
                    }
                }
            }
        }
        
        // Check if wave is complete
        function checkWaveCompletion() {
            if (waveInProgress && enemies.length === 0) {
                waveInProgress = false;
                waveNumber++;
                
                // Bonus gold for completing wave
                gold += 50 + waveNumber * 10;
                
                updateUI();
                document.getElementById('start-wave').disabled = false;
            }
        }
        
        // Create floating text effect
        function createFloatingText(x, y, text, color) {
            const textElem = document.createElement('div');
            textElem.className = 'status-effect';
            textElem.style.left = x + 'px';
            textElem.style.top = y + 'px';
            textElem.style.color = color;
            textElem.textContent = text;
            document.body.appendChild(textElem);
            
            // Remove after animation
            setTimeout(() => {
                document.body.removeChild(textElem);
            }, 1000);
        }
        
        // Update UI elements
        function updateUI() {
            document.getElementById('gold').textContent = gold;
            document.getElementById('lives').textContent = lives;
            document.getElementById('wave').textContent = waveNumber;
            document.getElementById('enemies').textContent = enemies.length;
            
            // Update tower buttons based on available gold
            document.getElementById('fire-tower').disabled = gold < towerTypes.fire.baseCost;
            document.getElementById('ice-tower').disabled = gold < towerTypes.ice.baseCost;
            document.getElementById('poison-tower').disabled = gold < towerTypes.poison.baseCost;
            document.getElementById('barracks').disabled = gold < towerTypes.barracks.baseCost;
            
            // Update upgrade panel if tower is selected
            if (selectedTower) {
                updateUpgradePanel();
            }
        }
        
        // Draw the game
        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid();
            
            // Draw path
            drawPath();
            
            // Draw towers
            drawTowers();
            
            // Draw soldiers
            drawSoldiers();
            
            // Draw enemies
            drawEnemies();
            
            // Draw projectiles
            drawProjectiles();
            
            // Draw selected tower range
            drawSelectedTowerRange();
        }
        
        // Draw the grid
        function drawGrid() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            for (let y = 0; y < gameHeight; y++) {
                for (let x = 0; x < gameWidth; x++) {
                    ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // Draw the path
        function drawPath() {
            for (let i = 0; i < path.length; i++) {
                const { x, y } = path[i];
                ctx.fillStyle = '#555';
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
            
            // Draw start and end
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(path[0].x * cellSize, path[0].y * cellSize, cellSize, cellSize);
            
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(path[path.length - 1].x * cellSize, path[path.length - 1].y * cellSize, cellSize, cellSize);
        }
        
        // Draw the towers
        function drawTowers() {
            for (const tower of towers) {
                const towerInfo = towerTypes[tower.type];
                
                // Draw tower
                ctx.fillStyle = towerInfo.color;
                ctx.fillRect(tower.x * cellSize, tower.y * cellSize, cellSize, cellSize);
                
                // Draw level indicator
                ctx.fillStyle = '#fff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(tower.level, (tower.x + 0.5) * cellSize, (tower.y + 0.5) * cellSize);
            }
        }
        
        // Draw the soldiers
        function drawSoldiers() {
            for (const soldier of soldiers) {
                // Draw soldier body
                ctx.fillStyle = soldier.color;
                ctx.beginPath();
                ctx.arc(soldier.x, soldier.y, cellSize / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw health bar
                const healthPercent = soldier.health / soldier.maxHealth;
                const barWidth = cellSize / 2;
                const barHeight = 4;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(soldier.x - barWidth / 2, soldier.y - cellSize / 4 - barHeight - 2, barWidth, barHeight);
                
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(soldier.x - barWidth / 2, soldier.y - cellSize / 4 - barHeight - 2, barWidth * healthPercent, barHeight);
            }
        }
        
        // Draw the enemies
        function drawEnemies() {
            for (const enemy of enemies) {
                // Draw enemy body
                ctx.fillStyle = enemy.color;
                
                // Different shapes for different enemies
                if (enemy.type === 'normal') {
                    ctx.fillRect(enemy.x - cellSize / 4, enemy.y - cellSize / 4, cellSize / 2, cellSize / 2);
                } else if (enemy.type === 'fast') {
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y - cellSize / 3);
                    ctx.lineTo(enemy.x + cellSize / 3, enemy.y + cellSize / 3);
                    ctx.lineTo(enemy.x - cellSize / 3, enemy.y + cellSize / 3);
                    ctx.closePath();
                    ctx.fill();
                } else if (enemy.type === 'armored') {
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, cellSize / 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (enemy.type === 'magic') {
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y - cellSize / 3);
                    ctx.lineTo(enemy.x + cellSize / 3, enemy.y);
                    ctx.lineTo(enemy.x, enemy.y + cellSize / 3);
                    ctx.lineTo(enemy.x - cellSize / 3, enemy.y);
                    ctx.closePath();
                    ctx.fill();
                } else if (enemy.type === 'boss') {
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, cellSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw health bar
                const healthPercent = enemy.health / enemy.maxHealth;
                const barWidth = cellSize;
                const barHeight = 5;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - cellSize / 2 - barHeight - 2, barWidth, barHeight);
                
                // Health color based on percentage
                if (healthPercent > 0.6) {
                    ctx.fillStyle = '#00ff00';
                } else if (healthPercent > 0.3) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - cellSize / 2 - barHeight - 2, barWidth * healthPercent, barHeight);
                
                // Draw effect indicators
                if (enemy.effects.length > 0) {
                    let offsetX = -10;
                    
                    for (const effect of enemy.effects) {
                        ctx.fillStyle = effect.color;
                        ctx.beginPath();
                        ctx.arc(enemy.x + offsetX, enemy.y - cellSize / 2 - 10, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        offsetX += 8;
                    }
                }
            }
        }
        
        // Draw the projectiles
        function drawProjectiles() {
            for (const projectile of projectiles) {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw selected tower range
        function drawSelectedTowerRange() {
            if (selectedTower) {
                const towerInfo = towerTypes[selectedTower.type];
                const levelInfo = towerInfo.levels[selectedTower.level - 1];
                
                if (selectedTower.type !== 'barracks') {
                    const range = levelInfo.range;
                    ctx.beginPath();
                    ctx.arc(
                        (selectedTower.x + 0.5) * cellSize,
                        (selectedTower.y + 0.5) * cellSize,
                        range * cellSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.strokeStyle = towerInfo.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = `${towerInfo.color}33`;
                    ctx.fill();
                }
            }
        }
        
        // Restart the game
        function restartGame() {
            document.getElementById('game-over').style.display = 'none';
            initializeGame();
        }
        
        // Game loop
        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
